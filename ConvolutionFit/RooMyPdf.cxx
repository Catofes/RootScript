/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/

// Your description goes here... 

#include <complex>
#include <RooMath.h>
#include <chrono>
#include "Riostream.h"

#include "RooMyPdf.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include "TMath.h"
#include "fastgl.h"

ClassImp(RooMyPdf)

RooMyPdf::RooMyPdf(const char *name, const char *title,
                   RooAbsReal &_x, RooAbsReal &_mean, RooAbsReal &_width, int _method) :
        RooAbsPdf(name, title),
        x("x", "x", this, _x),
        mean("mean", "mean", this, _mean),
        width("width", "Breit-Wigner Width", this, _width),
        method(_method)
{
    string a = "time_";
    a += string(name);
    h = new TH1F(a.c_str(), "time", 1000, 0, 3000);
}


RooMyPdf::RooMyPdf(const RooMyPdf &other, const char *name) :
        RooAbsPdf(other, name),
        x("x", this, other.x),
        mean("mean", this, other.mean),
        width("width", this, other.width),
        method(other.method)
{
    h = other.h;
}


Double_t RooMyPdf::sub_f(Double_t t) const
{
    Double_t w = (width > 0) ? width : -width;
    Double_t arg = t - mean;
    return (1. / (arg * arg + 0.25 * w * w));
}

Double_t RooMyPdf::sub_sigma(Double_t t) const
{
    return 0.5;
}

// F(t) = f(t) * \frac{1}{\sigma (t)} \exp{-\frac{(t-x)^2}{2*\sigma^2(t)}}
Double_t RooMyPdf::sub_evaluate(Double_t t) const
{
    auto start = std::chrono::high_resolution_clock::now();

    Double_t s = (sub_sigma(t) > 0) ? sub_sigma(t) : -sub_sigma(t);
    Double_t arg = t - x;
    Double_t coef = -0.5 / (s * s);
    double_t result = sub_f(t) * exp(coef * arg * arg) * 1 / s;

    auto finish = std::chrono::high_resolution_clock::now();
    h->Fill(std::chrono::duration_cast<std::chrono::nanoseconds>(finish - start).count());

    return result;
}

Double_t RooMyPdf::gaus_evaluate() const
{
    auto start = std::chrono::high_resolution_clock::now();

    Double_t upper = x.max();
    Double_t lower = x.min();
    Double_t result = 0;
    for (int i = 0; i < 10000; i++) {
        fastgl::QuadPair p = fastgl::GLPair(10000, i + 1);
        result += p.weight * sub_evaluate((upper - lower) / 2. * p.x() + (upper + lower) / 2.);
    }
    result = (upper - lower) / 2. * result;

    auto finish = std::chrono::high_resolution_clock::now();
    h->Fill(std::chrono::duration_cast<std::chrono::nanoseconds>(finish - start).count());

    return result;
}

Double_t RooMyPdf::normal_evaluate() const
{
    int cut = 10000;
    double upper = x.max();
    double lower = x.min();
    double step = (upper - lower) / cut;
    double result = 0;
    for (int i = 0; i < cut; i++) {
        double point = lower + (i + 0.5) * step;
        result += sub_evaluate(point) * step;
    }
    return result;
}

Double_t RooMyPdf::evaluate() const
{
    switch (method) {
        case 0:
            return gaus_evaluate();
        case 1:
            return normal_evaluate();
    }
}

